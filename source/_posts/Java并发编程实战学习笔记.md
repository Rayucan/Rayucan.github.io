---
title: Java并发编程实战学习笔记
date: 2021-07-13 11:08:22
tags: JavaSE
categories: 笔记

---

记录书中一些个人觉得重要的部分。

<!-- more -->

# 第 0 部分

## 简介

> 为什么要编写并发程序？
>
> 1. **线程**是 Java 语言中不可或缺的重要功能
> 2. **线程**能充分发挥多处理器系统强大的计算能力

**线程**被称为**轻量级进程**，大多数操作系统以**线程**为基本调度单位，而不是**进程**。

**线程**彼此独立执行，前提是没有明确的**协同机制**。

**同一进程**中所有**线程**都共享**进程**的内存地址空间，也就是说，这些**线程**都能访问相同的变量并在同一个堆上分配对象。

**线程**需要实现更精细的数据共享机制，否则**线程**同时使用某一变量时，将造成不可预计的后果。

### 线程带来的风险

#### 安全性问题

> 安全性的含义是"永远不发生糟糕的事情"

```java
@NotThreadSafe
public class UnsafeSequence{
    private int i;
    
    public int getNext(){
        return i++;
    }
}
```

递增运算 i++ 看似是单个操作，实际上包含三个独立操作：

* 读取 i
* i 加 1
* 计算结果写入 i

程序运行时，**多个线程**之间的操作可能交替执行，这是一种常见的并发安全问题，称为**竞态条件**。

多线程环境下 getValue() 是否会返回唯一正确的值，取决于**线程**交替执行方式，这并不是我们希望看到的情况。

> 由于多个**线程**共享相同的内存地址空间，且并发运行，因此可能会访问或修改**其他线程**正在使用的变量，这种方式带来便利的同时也带来巨大的风险：
>
> **线程**会造成**无法预测**的数据变化，从而导致错误。

要使**多线程程序**的行为可以预测，必须对**共享变量**的访问操作进行协同，这样**线程**之间才不会彼此干扰。

通过将 getNext() 修改为**同步方法**，可以防止错误的交替执行情况：

```java
@ThreadSafe
public class Sequence{
    private int i;
    
    public synchronized int getNext(){
        return i++;
    }
}
```

在开发并发程序时，一定要注意**线程安全性**是不可破坏的。

安全性不仅对于**多线程程序**很重要，对于**单线程程序**也同样重要。

**线程**还会导致一些在**单线程程序**中不会出现的问题，如活跃性问题。

#### 活跃性问题

> 活跃性意为"某件**正确的事情**最终会发生"

当某个操作无法继续执行时，就会发生**活跃性问题**。

活跃性问题的形式之一就是**无限循环**，而使处于循环之后的代码无法执行。

**线程**还会带来其他某些活跃性问题，例如**线程A**等待**线程B**释放资源，而**线程B**永远不释放该资源，那么**线程A**就会永远等待下去。

**死锁**、**饥饿**、**活锁**均属于活跃性问题。

#### 性能问题

> 性能问题与活跃性问题密切相关，实际上"某件**正确的事情**最终会发生"还远远不够，我们通常希望"**正确的事情**尽快发生"

在**多线程程序**中，当线程调度器**临时挂起活跃线程**，转而运行**另一个线程**，就会频繁出现**上下文切换操作**。

**上下文切换操作**会带来极大的开销：保存和恢复执行上下文，丢失局部性，并且 CPU 时间将更多消耗在**线程调度**而不是**线程运行**上。

# 第 1 部分 基础知识

## 线程安全性

> 编写线程安全的代码，其核心在于**要对状态访问操作进行管理**，特别是对**共享的**和**可变的**状态的访问。
>
> "共享"意味着**变量可以同时被多个线程访问**，"可变"意味着**变量的值在其生命周期内可以发生变化**。

一个对象**是否需要是线程安全的**，取决于它**是否被多个线程访问**。

当**多个线程**访问某个状态变量并且其中有**一个线程**执行写入操作时，必须采用**同步机制**来协同这些线程对变量的访问。

如果**多个线程**访问**同一个可变的状态变量**时，没有采用合适的同步，那么程序就可能出现错误。

> 有三种方式可以解决以上问题：
>
> * 不在线程之间共享该状态变量
> * 将状态变量修改为不可变的变量
> * 在访问状态变量时使用同步

### 线程安全性的定义

在**线程安全性**的定义中，最核心的概念就是**正确性**。

**正确性**的含义是，某个类的行为与其规范完全一致。

对**正确性**给出清晰的定义后，就可以接着定义**线程安全性**：

> 当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。

### 原子性

```java
@NotThreadSafe
public class UnsafeCountingFactorizer implements Servlet{
    private long count = 0;
    
    public long getCount(){
        return count;
    }
    
    public void service(ServletRequest req, ServletResponse resp){
        ...
        ++count;
        ...
    }
}
```

以上程序中，我们希望增加一个 "Hit Counter" 来统计所处理请求的数量，每处理一个请求就将这个值加 1。

不幸的是，UnsafeCountingFactorizer 并不是线程安全的，与之前的 UnsafeSequence 一样，这个类很可能会丢失一些更新操作。

递增操作 `++count` 并非**原子的**，即它并不会作为一个**不可分割的**操作来执行。

同理，`++count` 包含了三个独立的操作：

* 读取 count 值
* 值加 1
* 计算结果写入 count

这是一个 "**读取-修改-写入**" 的操作序列，并且结果状态依赖于之前的状态。

#### 竞态条件

当某个计算的正确性取决于**多个线程**的交替执行时序，那么就会发生**竞态条件**。

> 换句话说，计算结果取决于运气。

最常见的竞态条件类型是 "**先检查后执行**(Check-Then-Act)" 操作，即通过一个**可能失效**的结果来决定下一步操作。

#### 复合操作

要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式**防止其他线程使用这个变量**。

> 假定两个操作A和B，从执行A的线程看，当另一个线程执行B时，要么**将B全部执行完毕**，要么**完全不执行B**，此时A和B彼此来说是原子的。

为了确保线程安全性，"**先检查后执行**" 和 "**读取-修改-写入**" 等操作必须是原子的。

以上操作统称为**复合操作**：包含了一组必须以原子方式执行的操作以确保线程安全性。

### 加锁机制

#### 内置锁

Java 提供了一种内置的锁机制来支持**原子性**：**同步代码块**(Synchronized Block)。

同步代码块包含两部分：

* 锁对象
* 由这个锁保护的代码块

```java
synchronized(lock){
    ...
}
```

> 以关键字 synchronized 修饰的方法就是一个横跨整个方法体的**同步代码块**，该同步代码块的锁是**调用方法的对象**。
>
> 静态 synchronized 方法以 **Class对象** 作为锁。

**每个 Java 对象**都可以用作一个实现同步的锁，称为**内置锁**或**监视器锁**。

线程在**进入同步代码块之前自动获得锁**，并在**退出同步代码块时自动释放锁**(无论正常退出，还是抛出异常退出)。

获得内置锁的**唯一途径**就是**进入由这个锁保护的同步代码块或方法**。

Java 的内置锁相当于一种**互斥体**(或者**互斥锁**)，这意味着**最多只有一个线程**能持有这种锁。

> 当线程A尝试获取线程B持有的锁时，线程A必须等待或阻塞，直到线程B释放锁。
>
> 如果B永远不释放锁，那么A将永远等待下去。

#### 重入

内置锁是**可重入的**，因此，当某个线程试图获得一个**已经由自己持有的锁**，这个请求就会成功。

**重入**的一个实现方法是，为每个锁关联一个**获取计数值**和一个**所有者线程**。

> 当计数值为 0 时，这个锁没有被任何线程持有。
>
> 当线程请求一个**未被持有**的锁时，JVM 记下锁的持有者，并将获取计数值置 1。
>
> 如果**同一个线程**再次获取这个锁，计数值递增；退出同步代码块时，计数值递减；当计数值归 0，这个锁将被释放。

### 用锁来保护状态

对于可能被**多个线程**同时访问的可变状态变量，在访问它时都需要持有同一个锁，此时，我们称此状态变量是由这个锁保护的。

每个共享的和可变的变量都应该**只由一个锁保护**，从而使维护人员知道从何入手。

并非所有数据都需要锁的保护，只有**被多个线程同时访问的可变数据**才需要通过锁来保护。

当某个变量由锁来保护时，意味着每次访问这个变量时都需要首先获得锁，确保同一时刻只有一个线程访问这个变量。

## 对象的共享

同步还有另一个重要的方面：**内存可见性**。

我们不仅希望防止某个线程正在使用对象状态时另一个线程修改该状态，还希望确保**一个线程修改了对象状态后，其他线程能够看到发生的变化**。

### 可见性

当**读操作**和**写操作**在**不同的线程**中执行时，我们无法确保执行**读操作**的线程能及时看到其他线程**写入**的值。

为了确保**多个线程**对内存写入操作的可见性，必须使用同步机制。

#### 失效数据

缺乏同步的程序中，当**读线程**查看变量时，可能会得到一个**已经失效的值**。

除非每次访问变量时都使用同步，否则很可能获得该变量的失效值。

更糟糕的是，失效值可能不会同时出现：一个线程可能获得某个变量的最新值，而获得另一个变量的失效值。

```java
@NotThreadSafe
public class MutableInteger{
    private int value;
    
    public int get(){
        return value;
    }
    
    public void set(int value){
        this.value = value;
    }
}
```

MutableInteger 不是线程安全的，get 与 set 都没有在同步的情况下访问 value。

如果某个线程调用了 **set** ，那么另一个正在调用 **get** 的线程可能会看到更新后的 value ，也可能看不到。

> 仅对 **set** 方法进行同步是不够的，调用 **get** 的线程仍然会看到失效值。

#### 加锁与可见性

内置锁可以用于确保**某个线程**以一种**可预测**的方式查看**另一个线程**的执行结果

即：当线程B执行**由锁保护的同步代码块**时，可以看到线程A之前在**同一个同步代码块**中的所有操作结果。

> 现在我们可以进一步理解，为什么访问某个共享且可变的变量时要求**所有线程在同一个锁上同步**。
>
> 就是为了确保**某个线程**写入该变量的值对于**其他线程**来说是可见的。

#### Volatile 变量

> Java 语言提供了一种**稍弱的同步机制**，即 volatile 变量，用来确保将**变量的更新操作**通知到其他线程

volatile 变量不会被缓存在寄存器或对其他处理器不可见的地方，因此在读取 volatile 变量时**总会返回最新写入的值**。

但是，在访问 volatile 变量时**不会执行加锁操作**，也就不会使执行线程阻塞，因此 volatile 变量是一种比 sychronized 关键字**更轻量级**的同步机制。

> 加锁机制既可以确保**可见性**，又可以确保**原子性**。
>
> 而 volatile 变量只能确保**可见性**。

### 发布与逸出

> "发布"一个对象是指，使对象能够在**当前作用域以外**的代码中使用。
>
> 当某个**不应该发布**的对象被发布时，称为"逸出"。

发布对象的最简单方法是将**对象的引用**保存到一个**公有的静态变量**中：

```java
public static Set<String> set;

public void initialize(){
    set = new HashSet<String>();
}
```

initialize 方法实例化一个 HashSet 对象，并保存到 set 中以发布该对象。

------

当发布某个对象时，可能会**间接发布**其他对象。

如果将一个 String 对象添加到 set 中，那么同样会发布这个对象，因为这个集合可以被遍历。

同理，在一个**非私有的方法**中返回对象引用，同样会发布返回的对象：

```java
class UnsafeStates{
    private String[] A = new String[] {
        "ni","hao",...
    };
    
    public String[] getA{
        return A;
    }
}
```

如果按照以上方式发布 A，就会出现问题，因为**任何调用者都可以修改数组 A 的内容**。

数组 A 已经逸出了其作用域，这个**私有变量**已经被发布了。

> 当发布一个对象时，该对象**非私有域**中所有对象同样会被发布。

假定一个类 C，对于 C 来说，"外部方法"是指**行为并不完全由 C 规定的方法**，包括**其他类中的方法**以及类 C 中**可以被改写的方法(**非 private、非 final)。

当一个对象传递给外部方法时，相当于发布了这个对象。

最后一种发布对象的机制就是**发布一个内部类实例**：

```java
public class ThisEscape{    
    public ThisEscape(EventSource source){        
        source.rergisterListener{
            new EventListener(){
                public void onEvent(Event e){
                    doSomething(e);
                }
            }
        }
        
    }
}

```

当 ThisEscape 发布 EventListener 时，也**隐含发布了其本身**，这个内部类实例包含对 ThisEscape 实例的隐含引用。

ThisEscape 中给出了一个特殊的逸出事例，即 **this 引用在构造函数中逸出**。

如果 this 引用在构造过程中逸出，那么这种对象就被认为是**不正确构造**。

> 不要在构造中使 this 引用逸出。

#### 安全的对象构造

在构造过程中，使 this 引用逸出的一个**常见错误**是**在构造函数中启动一个线程**。

当对象在其构造函数中创建一个线程时，无论是**显式创建**(将它传递给构造函数)，还是**隐式创建**(由于 Thread 或 Runnable 是该对象的一个内部类)，this 引用都会被新创建的线程共享。

